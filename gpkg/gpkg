#!/bin/bash

#
# gpkg -- UI program for Xiange Linux package management system 
# 
# by Zhang Lihui <swordhuihui@gmail.com>, 2010-04-13, 15:58
#

#path define
XGPATH_RAW=/var/xiange
XGPATH=${XGROOT}${XGPATH_RAW}
XGPATH_TOOLS=$XGPATH/tools
XGPATH_LIB=$XGPATH/xglibs
XGPATH_SOURCE_RAW=$XGPATH/sources
XGPATH_PACKAGE=$XGPATH/packages
XGPATH_DB=$XGPATH/db
XGPATH_DB_RAW=$XGPATH_RAW/db
XGPATH_SCRIPT=$XGPATH_LIB

XGPATH_BUILD=/tmp/xiange
XGPATH_DEST=

ntmpdir=/tmp/xglfs_check
nlfsfile=index.html
nblfsfile=index2.html

#compile parameters
XGB_ARCH=$(uname -m)
XGB_PREFIX=
CFLAGS="-march=native -mtune=native -O2 -fomit-frame-pointer -pipe"
CXXFLAGS="$CFLAGS"
XGINST_PREFIX="--prefix=/usr"
XGB_CONFIG="$XGINST_PREFIX "
XG_I18N="en zh_CN"
XGPARA_MAKE="-j `nproc`"


#GIT server
XG_GITSVR="git://github.com/swordhui/xglibs.git"

#parameters for wget
XG_WGET_PARA="--no-check-certificate"

#color defines
## Set color commands, used via $ECHO
# Please consult `man console_codes for more information
# under the "ECMA-48 Set Graphics Rendition" section
#
# Warning: when switching from a 8bit to a 9bit font,
# the linux console will reinterpret the bold (1;) to
# the top 256 glyphs of the 9bit font. This does
# not affect framebuffer consoles
NORMAL="\\033[0;39m" # Standard console grey
SUCCESS="\\033[1;32m" # Success is green
WARNING="\\033[1;33m" # Warnings are yellow
FAILURE="\\033[1;31m" # Failures are red
INFO="\\033[1;36m" # Information is light cyan
BRACKET="\\033[1;34m" # Brackets are blue

if [ "$GPKGNC" == "1" ]; then
	NORMAL="" # Standard console grey
	SUCCESS="" # Success is green
	WARNING="" # Warnings are yellow
	FAILURE="" # Failures are red
	INFO="" # Information is light cyan
	BRACKET="" # Brackets are blue
fi


#
# version and  usage 
#
gpkg_version=0.10.64.1
gpkg_usage="
gpkg $SUCCESS$gpkg_version$NORMAL, usage:\n
	$INFO\t-v            	$NORMAL\t\tshow current version\n
	$INFO\t--sync [path] 	$NORMAL\tsync xglibs via git to [path]/var/xiange\n
	$INFO\t-s package	$NORMAL\tsearch package\n
	$INFO\t-S file 		$NORMAL\tsearch which package file belongs to\n
	$INFO\t-d package 	$NORMAL\tdownload package\n
	$INFO\t-i package 	$NORMAL\tinstall package\n
	$INFO\t-ip package 	$NORMAL\tbuild packge but no install, no dep check\n
	$INFO\t-im package 	$NORMAL\tbuild only, use current user, no su\n
	$INFO\t-c package 	$NORMAL\tcheck package integrity\n
	$INFO\t-D package 	$NORMAL\tremove package\n
	$INFO\t-I  		$NORMAL\t\tlist installed package\n
	$INFO\t-l package 	$NORMAL\tlist all files in installed package\n
	$INFO\t-ib xgp_file	$NORMAL\tinstall binary package to system\n
	$INFO\t-F path		$NORMAL\tfind orphans in path. e.g. not belongs to any package\n
	$INFO\t-p package	$NORMAL\tshow package dependence\n
	$INFO\t-ckb package	$NORMAL\tcheck binary packages\n
	$INFO\t-chroot path	$NORMAL\tchroot to new system, for system installing\n
	$INFO\t-unchroot path	$NORMAL\tun-chroot\n
	$INFO\t-rdep package	$NORMAL\tshow reverse dependence\n
	$INFO\t-pack dir name version 	$NORMAL\tpack all files in dir to xgb file.\n
	$INFO\t-packraw package $NORMAL\tcontinue install compiled package.\n
	$INFO\t-cu\t$NORMAL\tcheck which package can be upgrade.\n
	$INFO\t-cn\t$NORMAL\tcheck new packages in xglib.\n
	$INFO\t-cklfs\t$NORMAL\tcheck new packages from lfs/blfs website.\n
	$INFO\tedit package	$NORMAL\tedit xgb file with vim\n
	$INFO\tnew type/package-version	$NORMAL\tnew xgb file with vim\n
	$INFO\trm package-version	$NORMAL\tremove xgb file with vim\n
	$INFO\tcs package	$NORMAL\tshow script path of specified package\n
	$INFO\tcd package	$NORMAL\tshow db path of specified package\n
	$INFO\t-info		$NORMAL\t\tshow gpkg parameters. to modify parameters, gpkg info > $XGROOT/etc/xgparas, then edit it.\n
XianGe base is at $XGPATH\n
	$INFO\tGPKGNC$NORMAL\t\t\"GPKGNC=1 gpkg\" to remove output color.\n
"

#only pack?
if [ "x$pack_only" == "x" ]; then
	pack_only="0"
fi

gpkg_show_usage()
{
	echo -e $gpkg_usage
}

xgb_init()
{
	echo "on dummy xgb_init"
}

xgb_postinst()
{
	echo "on dummy xgb_postinst"
}

xgb_prerm()
{
	echo "on dummy xgb_prerm"
}

xgb_postrm()
{
	echo "on dummy xgb_postrm"
}

xgb_mkmenu()
{
	local i

	#conver icon if needed
	if [ -n "$imgconv1" ]; then
		mkdir -p $(dirname $XGPATH_DEST$imgconv2)
		err_check "imgconv: mkdir 1 failed."

		convert $convpara $XGPATH_DEST$imgconv1 -resize 32x32 $XGPATH_DEST$imgconv2
		err_check "imgconv: conver failed."
	fi

	#destfile
	mkdir -p $(dirname $menufile)
	err_check "mkmenu: mkdir failed."

	touch $menufile
	err_check "mkmenu: touch failed."

	#write all names
	for i in ${!Name[@]};
	do
		echo "Name[$i]=\"${Name[$i]}\"" >> $menufile
	done

	echo "Icon=\"$imgconv2\"" >> $menufile
	echo "Exec=\"$menu_cmd\"" >> $menufile
	err_check "mkmenu: write failed."

	return 0
}

xgb_update_last()
{
	mkdir -p $XGPATH_DB/info
	touch $XGPATH_DB/info/last
}

#
# colourful echo 
#

#show info in cyan color, $1 is information.
showinfo()
{
	echo -e  $INFO"$1"$NORMAL
}

#show OK message in green color, $1 is information.
showOK()
{
	echo -e $SUCCESS"$1"$NORMAL
}

#show OK message in green color, $1 is information.
showFailed()
{
	echo -e $FAILURE"$1"$NORMAL
}

#
# string functions
#

#check: if $2 in $1, return 1, else return 0
str_isIn()
{
	if [ "${1/$2/}" != "${1}" ]; then
		return 1
	else
		return 0
	fi
}

#check: if $2 in $1 exactly. return 1 if in, return 0 if not in.
str_isInExactly()
{
	local str

	for str in $1
	do
		if [ "$str" == "$2" ]; then
			#in string.
			return 1
		fi
	done

	return 0
}

#
# Error check
#

#check return code. show $1 if error.
err_check()
{
	if [ $? != 0 ]; then
		showFailed "$1" >&2
		exit 1
	fi
}


#
# version control
#

#parse atom to $N, $V, $R, 
#by tomgrean @ LinuxSir, 2009-09-11, 20:02
#improved by Sword, 2014-03-10
atom_parse()
{
	local ATOM
	local VR
	local ATOM_ALL


	ATOM_ALL="${1%.xgb}"

	#get T
	ATOM=${ATOM_ALL##*/}
	T=${ATOM_ALL%$ATOM}
	T=${T%/}
	T=${T##*/}

	N="${ATOM%-[0-9]*}"
	VR="${ATOM##$N}"
	VR="${VR##-}"
	#echo "T=$T, N=$N, VR=$VR"


	V="${VR%-r[0-9]*}"
	R="${VR##$V}"
}


#parse with path, suchas "/var/xiange/db/app-editor/vim/vim-7.2.401.xgb"
atom_parse_path()
{
	local atom

	atom=${1##*/}
	T=${1%/*}
	T=${T%/*}
	T=${T##*/}

	atom_parse "$T/$atom"
}

#compare 2 versions, such 2.6.9 and 2.6.10
#return 0 if same. 
#return 1 if $1 is grater than $2 
#return 2 if $1 is lesser then $2
#by lastart @ LinuxSir
atom_vercmp()
{
	v1=$1.
	v2=$2.
	while true
	do
		a=${v1%%.*}
		b=${v2%%.*}
		[ -z "$a" ] && [ -z "$b" ] &&  return 0
		[ "$a"0 -gt "$b"0 ] && return 1
		[ "$a"0 -lt "$b"0 ] && return 2
		v1="${v1#*.}"
		v2="${v2#*.}"
	done
}

#compare 2 atoms, such as linux-2.6.9.xgb and linux-2.6.10.xgb
#return 0 if same. 
#return 1 if $1 is grater than $2 
#return 2 if $1 is lesser then $2
atom_cmp()
{
	local R1
	local V1
	local N1

	#echo "Begin Compare: $1 $2"

	atom_parse $1
	R1=$R
	V1=$V
	N1=$N
	#echo "N1=$N1, V1=$V1, R1=$R1"

	atom_parse $2
	#echo "N2=$N, V2=$V, R2=$R"

	#compare version
	atom_vercmp $V1 $V
}

#compare 2 atoms pth, such as /var/xiange/sys/linux-2.6.9.xgb and linux-2.6.10.xgb
#return 0 if same. 
#return 1 if $1 is grater than $2 
#return 2 if $1 is lesser then $2
atom_cmp_path()
{
	local R1
	local V1
	local N1

	#echo "Begin Compare: $1 $2"

	atom_parse_path $1
	R1=$R
	V1=$V
	N1=$N
	#echo "N1=$N1, V1=$V1, R1=$R1"

	atom_parse_path $2
	#echo "N2=$N, V2=$V, R2=$R"

	#compare version
	atom_vercmp $V1 $V
}
#
# CSV file operation
#

#split csv line. 
#input: $1="good,i love u,123"
#output: count=3, value[0]=good, value[1]="i love u", value[2]=123
csv_split()
{
	count=0
	local retv=$1
	unset value

	while [ -n "$retv" ]
	do
		value[$count]=${retv%%,*}
		#echo "value_$count=${value[$count]}"

		retv=${retv#${value[$count]}}
		retv=${retv#,}
		#echo "retv=$retv"

		count=$(($count+1))
	done
}

#
# search packages
#

#list all pack types
gpkg_get_types()
{
	gpkg_types=`ls $XGPATH_LIB 2>/dev/null`
}

gpkg_get_packages()
{
	gpkg_packs=`ls $XGPATH_LIB/$1 2>/dev/null`
}

#Get Newest file in dir $1
#return path of the newest on in $newest
gpkg_getnewest()
{
	local file
	newest=""

	for file in $results
	do
		#echo "Check $file"
		if [ -z $newest ]; then
			newest=$file
			#echo "First is $file"
		else
			#compare 
			#echo "compare $file $newest"
			atom_cmp_path $file $newest
			[ "$?" == "1" ] && newest=$file
			#echo "after compare: new=$newest"

		fi
	done
}

#get all xgb versions, ret to $allver
#$1 is path 
gpkg_getallxgbver()
{
	local files
	local file
	allver=""

	files=`ls -t $1/*.xgb 2>/dev/null`
	for file in $files
	do
		atom_parse_path $file
		if [ -z "$allver" ]; then
			allver="$V$R"
		else
			allver+=" | $V$R"
		fi

		#include file for HOMEPAGE and DESCRIPTION
		. $file
	done
}

gpkg_searchInstalled()
{
	local searchpath=$XGPATH_DB/$1/$2	
	local findcnt=0

	local files=$(ls $searchpath/*.xgb 2>/dev/null)
	local file
	local -a value
	local t1
	local t2
	local tsize

	for file in $files
	do
		file=${file##*/}
		atom_parse $file

		#get date.
		IFS=, read -r -a value < $searchpath/$N-$V$R.date
		t1=${value[0]}
		t2=${value[1]}

		#get size, 
		csv_split `tail -n 1 $searchpath/$N-$V$R.file`
		tsize=${value[5]}

		printf "$NORMAL\tInstalled:$SUCCESS %s | %s %s $BRACKET%sK\n" $V$R $t1 $t2 $tsize 
		findcnt=$(($findcnt+1))
	done

	[ "$findcnt" == "0" ] && echo -e "$NORMAL\tInstalled:$FAILURE None"
}


#find one packge $1 is type, $2 is package name, $3 is index
gpkg_searchOK()
{
	local allver

	#show it.
	echo -e $FAILURE"* $1/$2"

	#get newest version
	gpkg_getallxgbver $XGPATH_LIB/$1/$2
	echo -e "$NORMAL\tAvailable:$INFO $allver"

	#search installed
	gpkg_searchInstalled $1 $2

	echo -e "$NORMAL\tDesc.    :$INFO $DESCRIPTION"
	echo -e "$NORMAL\tHomepage :$INFO $HOMEPAGE"

	#add blank line
	echo ""
}

#Search, $1 is atom with path, such as app-sys/linux
#or input linux only.
gpkg_search()
{
	local results
	local pack
	local count=0
	local iname
	local lastiname=""
	local lastitype=""

	#echo "p1=$1"

	#parae input files
	atom_parse $1

	#echo "N=$N, T=$T"

	#find what?
	if [ "$N" == "" ]; then
		iname="*.xgb"
	else
		iname="*$N*.xgb"
	fi

	#type?
	if [ -n "$T" ]; then
		results=$(find -L $XGPATH_LIB -iname "$iname" 2>/dev/null | grep "/$T/")
	else
		results=$(find -L $XGPATH_LIB -iname "$iname" 2>/dev/null)
	fi

	for pack in $results
	do
		atom_parse_path $pack

		#check same with the last one?
		if [ "$T" == "$lastitype" -a "$N" == "$lastiname" ]; then
			#skip.
			continue
		fi

		count=$(($count + 1))
		lastitype=$T
		lastiname=$N
		gpkg_searchOK $T $N $count
	done
}


#
# download packet
#

#check and download package, $1 is URL, $2 is local file name.
check_and_download_raw()
{
	local fname=$2
	local retry

	#retry 3 times
	for((retry=0; retry<3; retry++))
	do
		#check if package has already exist.
		if [ -f ${XGPATH_SOURCE}/${fname} ]; then
			printf "%s exists, Skip.\n" $fname
			return 0
		else
			#check old file
			if [ -f ${XGPATH_SOURCE_RAW}/${fname} ]; then
				printf "%s exists in old location, Skip.\n" $fname
				mv ${XGPATH_SOURCE_RAW}/${fname} ${XGPATH_SOURCE}
				err_check "move ${fname} to ${XGPATH_SOURCE_RAW} failed"
				return 0
			fi
			printf "downloading from %s, retry %d...\n" ${1} ${retry}

			if [ -f ${XGPATH_SOURCE}/${fname}.tmp ]; then
				XG_WGET_PARA+=" -c"
			fi
			

			wget $XG_WGET_PARA $1 -O ${XGPATH_SOURCE}/${fname}.tmp
			if [ "$?" == "0" ]; then
				#download ok.
				mv ${XGPATH_SOURCE}/${fname}.tmp ${XGPATH_SOURCE}/${fname}
				return 0
			fi
			sleep 2
		fi
	done

	printf "down load failed, quit.\n"
	return 1
}

#check and download package, $1 is URL.
check_and_download()
{
	local fname=${1##*/}

	#call raw mode.
	check_and_download_raw $1 $fname
}


# return specifid xgb files in $newest, with full path
# $1 is file atom with type, such as "sys-app/vim-7.2.404"
gpkg_getxgbfile()
{
	local results
	local pack
	local count=0
	local iname

	#echo "p1=$1"

	#parae input files
	atom_parse $1

	#echo "N=$N, T=$T"

	#find what?
	if [ "x$N" == "x" ]; then
		echo "No package specified."
		echo "Sample: "
		echo -e "\tgpkg -i vim"
		echo -e "\tgpkg -i vim-7.2.404"
		echo -e "\tgpkg -i app-editors/vim-7.2.404"
		exit 1
	fi

	if [ "x$V" == "x" ]; then
		#no version specified
		iname="$N-*.xgb"
	else
		iname="$N-$V$R.xgb"
	fi

	#type?
	if [ -n "$T" ]; then
		results=$(find -L "$XGPATH_LIB/$T/$N" -iname "$iname" 2>/dev/null)
	else
		results=$(find -L "$XGPATH_LIB" -iname "$iname" 2>/dev/null | grep "$N/")
	fi

	for pack in $results
	do
		#atom_parse_path $pack
		count=$(($count + 1))
		#echo "$count $pack"
	done

	#echo result=$results, V=$V, R=$R
	if [ "$count" == "0" ]; then
		#not found
		showFailed "$1 is not found." >&2
		return 2
	fi

	if [ "$count" == "1" ]; then
		#found 
		newest=$pack
		#echo "found $newest"
		return 0

	fi

	#more results, get the newest one
	gpkg_getnewest
	return 0
}

#begin download, $1 is atom with path,  such as 
#/var/sys-app/autoconf/autoconf-2.63-r1.xgb
gpkg_begin_download()
{
	local url

	#echo "begin download from $XGPATH_SCRIPT/$1"

	#find newest version.
	atom_parse_path $1
	showinfo ">> Begin download $N-$V$R..."

	#clear all routines by include template file
	. $XGPATH_LIB/template.xgb
	err_check "[Error] $XGPATH_LIB/template.xgb not found."

	#prepare XGB_CONFIG, CFLAGS, CPPFLAGS, XGINST_PREFIX
	export CFLAGS=$CFLAGS
	export CXXFLAGS=$CXXFLAGS
	export CPPFLAGS=$CFLAGS
	XGPATH_SCRIPT=$XGPATH_LIB/$T/$N
	XGPATH_SOURCE=$XGPATH_SOURCE_RAW/$N-$V$R

	#include package build scripts
	. $1
	err_check "[Error] $XGPATH_SCRIPT/$1 not found."

	#init build script file
	xgb_init

	#create source directory.
	mkdir -p $XGPATH_SOURCE
	err_check "[Error] Create dir $XGPATH_SOURCE failed."

	#download all files
	for url in ${SRC_URI}
	do
		#echo $url
		check_and_download $url
		err_check "[Error] download $url failed."
	done

	#check
	showOK ">> Download OK"
	return 0
}

gpkg_download()
{
	local newest

	#get xgb file
	gpkg_getxgbfile $1

	if [ "$?" == "0" ]; then
		#found, download it
		gpkg_begin_download $newest

	else
		#not found
		return 1
	fi
}


#
# Install package
#

gpkg_rm_dir_safe()
{
	local ldir

	if [ -L "$1" ]; then
		#symbol link, check link  
		ldir=$(realpath "$1")
		rm -d "$ldir" 2>/dev/null
		if [ "$?" == "0" ]; then
			rm -d "$1" 2>/dev/null
			showinfo "RM (D) $ldir"
			showinfo "RM (D) $1"
		fi
	else
		rm -d "$1" 2>/dev/null
		if [ "$?" == "0" ]; then
			showinfo "RM (D) $1"
		fi

	fi
}

#strip unnessesary i18n in path $1
gpkg_strip_i18n()
{
	local ipath="$1/locale"
	local i18ns=$(ls $ipath 2>/dev/null)
	local name

	for i in $i18ns
	do
		name=${i##*/}
		str_isIn "$XG_I18N" $name 
		if [ "$?" == "0" ]; then
			#not in XG_I18N, remove.
			showinfo ">> strip i18n $name.."
			rm -rf $ipath/$name
		fi
	done
}

#strip unnessesary i18n in man path.
gpkg_strip_mani18n()
{
	local ipath="$1/man"
	local i18ns=$(ls $ipath 2>/dev/null)
	local name

	for i in $i18ns
	do
		name=${i##*/}

		#skip man1 -- man9
		str_isIn "$name" "man"
		if [ "$?" == "1" ]; then
			continue
		fi

		str_isIn "$XG_I18N" $name 
		if [ "$?" == "0" ]; then
			#not in XG_I18N, remove.
			showinfo ">> strip man-i18n $name.."
			rm -rf $ipath/$name
		fi
	done
}

#strip binary in directory $1
gpkg_stip_bin()
{
	showinfo ">> strip debug info.."
	find $1/{,usr/}{bin,sbin} -type f \
  		-exec ${XGB_PREFIX}strip --strip-all '{}' ';' 2>/dev/null

	find $1/{,usr/}lib -type f \
  		-exec ${XGB_PREFIX}strip --strip-debug '{}' ';' 2>/dev/null
}

#compress man docs
gpkg_gzip_man()
{
	showinfo ">> compress man docs.."
	find $1/usr/{,share/}man -type f \
  		-exec gzip '{}' ';' 2>/dev/null
}

#compress info docs
gpkg_gzip_info()
{
	local ipath=""

	[ -d $1/usr/share/info ] && ipath=$1/usr/share/info
	[ -d $1/usr/info ] && ipath=$1/usr/info

	#quit if not found
	[ -z "$ipath" ] && return 0

	showinfo ">> compress $ipath"

	#first, rename dir.
	[ -f ${ipath}/dir ] && mv ${ipath}/{dir,dir-$N.info}
	find $ipath -type f \
  		-exec gzip '{}' ';' 2>/dev/null
}


#make .xgb file from  $XGPATH_DEST
gpkg_dopack()
{
	local destpath="$XGPATH_DEST/$XGPATH_DB_RAW/$T/$N"

	#generate file list
	cd $XGPATH_DEST
	find 2>/dev/null | xgfileinfo > /tmp/file-$N-$V$R
	err_check "call xgfileinfo failed."

	mkdir -p $destpath
	err_check "[Error] create db directory failed."

	#file list
	mv /tmp/file-$N-$V$R $destpath/$N-$V$R.file
	err_check "[Error] move file list failed."

	#configure result and zip it.
	if [ -f $XGPATH_BUILD/$N-$V$R.config ]; then
		mv $XGPATH_BUILD/$N-$V$R.config $destpath
		gzip $destpath/$N-$V$R.config
	fi

	#test result and zip it.
	if [ -f $XGPATH_BUILD/$N-$V$R.test ]; then
		mv $XGPATH_BUILD/$N-$V$R.test $destpath
		gzip $destpath/$N-$V$R.test
	fi

	#copy scripts file
	if [ -f $XGPATH_SCRIPT/$N-$V$R.xgb ]; then
		cp $XGPATH_SCRIPT/$N-$V$R.xgb $destpath/
		err_check "[Error] move file list failed."
	else
		touch $destpath/$N-$V$R.xgb
	fi

	if [ -f $XGPATH_BUILD/$N-$V$R.para ]; then
		mv $XGPATH_BUILD/$N-$V$R.para $destpath
	fi

	#date time
	date +%F,%T > $destpath/$N-$V$R.date

	#tar it.
	mkdir -p $XGPATH_PACKAGE
	showinfo ">> make packages... please wait a minute"
	tar cjpf $XGPATH_PACKAGE/$N-$V$R.xgp *
	err_check "make package failed."
	showinfo ">> $XGPATH_PACKAGE/$N-$V$R.xgp done." 

}

gpkg_mkpackage()
{

	#strip i18n
	gpkg_strip_i18n $XGPATH_DEST/usr/share

	#strip man i18n pages
	gpkg_strip_mani18n $XGPATH_DEST/usr
	gpkg_strip_mani18n $XGPATH_DEST/usr/share

	#strip bin
	gpkg_stip_bin $XGPATH_DEST


	#compress man docs
	gpkg_gzip_man $XGPATH_DEST
	gpkg_gzip_info $XGPATH_DEST

	gpkg_dopack


}

gpkg_rm_packgeinfo()
{
	local destpath=$XGPATH_SCRIPT

	#remove config file
	echo "RM (F) $destpath/$N-$V$R.config"
	rm -f $destpath/$N-$V$R.config
	rm -f $destpath/$N-$V$R.config.gz
	rm -f $destpath/$N-$V$R.para

	#remove scripts file
	echo "RM (F) $destpath/$N-$V$R.xgb"
	rm -f $destpath/$N-$V$R.xgb
	err_check ">> Remove $N-$V$R failed."

	#remove list file
	echo "RM (F) $destpath/$N-$V$R.file"
	rm -f $destpath/$N-$V$R.file

	#remove test file.
	echo "RM (F) $destpath/$N-$V$R.test"
	rm -f $destpath/$N-$V$R.test
	rm -f $destpath/$N-$V$R.test.gz

	#remove date file
	echo "RM (F) $destpath/$N-$V$R.file"
	rm -f $destpath/$N-$V$R.date

	#remove directory
	gpkg_rm_dir_safe $destpath
	gpkg_rm_dir_safe $XGPATH_DB/$T
	gpkg_rm_dir_safe $XGPATH_DB
}

#Check if already insalled. $T/$N$V 
gpkg_checkInst()
{
	local ifile

	oldinst_atom=""

	#echo "T=$T, N=$N"

	for ifile in $XGPATH_DB/$T/$N/*.file;
	do
		if [ -a "$ifile" ]; then
			#found
			oldinst_atom=$(basename $ifile .file)
			#echo "found, atom=$oldinst_atom"
			return 1
		fi
	done
	return 0
}

gpkg_beginbuild()
{
	local ret=0

	XGPATH_BUILD=/tmp/xiange/$N-$V$R
	XGPATH_DEST=$XGPATH_BUILD/pack


	# DO RM WITH CAUTION!! 
	rm -rf $XGPATH_BUILD

	showinfo ">> unpacking $N-$V$R..."
	mkdir -p $XGPATH_BUILD
	cd $XGPATH_BUILD
	xgb_unpack
	err_check "[Error] call xgb_unpack failed"

	#call config and store config result
	rm -f $XGPATH_BUILD/$N-$V$R.pipe
	mkfifo $XGPATH_BUILD/$N-$V$R.pipe
	tee $XGPATH_BUILD/$N-$V$R.config < $XGPATH_BUILD/$N-$V$R.pipe & 
	xgb_config >  $XGPATH_BUILD/$N-$V$R.pipe
	if [ "$?" != "0" ]; then
		sleep 1
		echo "[Error] call xgb_config failed"
		rm -f $XGPATH_BUILD/$N-$V$R.pipe
		exit 1
	fi

	#record correct config
	echo "XGB_ARCH=\"$XGB_ARCH\"" > $XGPATH_BUILD/$N-$V$R.para
	echo "XGB_PREFIX=\"$XGB_PREFIX\"" >> $XGPATH_BUILD/$N-$V$R.para
	echo "CFLAGS=\"$CFLAGS\"" >> $XGPATH_BUILD/$N-$V$R.para
	echo 'CXXFLAGS="$CFLAGS"' >> $XGPATH_BUILD/$N-$V$R.para
	echo "XG_I18N=\"$XG_I18N\"" >> $XGPATH_BUILD/$N-$V$R.para
	echo "XGB_CONFIG=\"$XGB_CONFIG\"" >> $XGPATH_BUILD/$N-$V$R.para
	echo "XGPARA_MAKE=\"$XGPARA_MAKE\"" >> $XGPATH_BUILD/$N-$V$R.para

	cpuname=$(cat /proc/cpuinfo | grep "model name" | head -n 1)
	echo "CPU_NAME=\"$cpuname\"" >> $XGPATH_BUILD/$N-$V$R.para
	echo "GPKG_VERSION=\"$gpkg_version\"" >> $XGPATH_BUILD/$N-$V$R.para


	#stort current path
	pwd > $XGPATH_BUILD/install_path

	#call build
	xgb_build
	err_check "[Error] call xgb_build failed"

	#check if possiable, and ignore result
	#store information to /tmp/xiange/$N-$V$R.test
	rm -f $XGPATH_BUILD/$N-$V$R.pipe2


	#do not check in cross compile environment
	if [ -z "$XGB_PREFIX" ]; then
		mkfifo $XGPATH_BUILD/$N-$V$R.pipe2
		tee $XGPATH_BUILD/$N-$V$R.test < $XGPATH_BUILD/$N-$V$R.pipe2 & 
		xgb_check > $XGPATH_BUILD/$N-$V$R.pipe2
		showinfo "check done, ret $?"
	fi
}

gpkg_begin_install()
{
	local newest
	local ret
	local iname
	local iver
	local irver
	local buildpath

	#parse input 
	#echo "atom=$1"
	atom_parse "$1"
	iname=$N
	iver=$V
	irver=$R

	#get xgb file
	gpkg_getxgbfile $1
	err_check "get xgb file from $1 failed.";

	atom_parse_path $newest

	#echo N=$N, V=$V, T=$T
	#include file.
	. $XGPATH_LIB/template.xgb
	err_check "include xgb template file failed."

	#call init
	XGPATH_SCRIPT=$XGPATH_LIB/$T/$N
	XGPATH_SOURCE=$XGPATH_SOURCE_RAW/$N-$V$R
	#echo script=$XGPATH_SCRIPT/$N-$V$R.xgb
	. $XGPATH_SCRIPT/$N-$V$R.xgb
	err_check "include xgb file failed."

	xgb_init > /dev/null 2>&1
	err_check "call xgb_init failed"


	XGPATH_BUILD=/tmp/xiange/$N-$V$R
	XGPATH_DEST=$XGPATH_BUILD/pack

	showinfo ">> finding install_path at $XGPATH_BUILD.."
	#echo "$XGPATH_BUILD"
	buildpath=$(cat $XGPATH_BUILD/install_path 2>/dev/null)
	err_check ">> install_path not found, compile not completed."
	echo "installing in $buildpath"

	pushd $buildpath > /dev/null
	gpkg_do_install
}

gpkg_do_install()
{
	#call install
	rm -rf $XGPATH_DEST
	mkdir -p $XGPATH_DEST
	xgb_install
	err_check "[Error] call xgb_install failed"
	
	#make package
	gpkg_mkpackage
	err_check "[Error] make binary package failed"

	if [ "$pack_only" == "0" ]; then
		#copy to root(upgrade)
		gpkg_upgrade_binary_package $XGPATH_PACKAGE/$N-$V$R.xgp
	else
		showinfo ">> $XGPATH_PACKAGE/$N-$V$R.xgp is ready."
	fi

	#clean up
	rm -rf $XGPATH_BUILD
	return 0
}


#$1 is xgb path file.
gpkg_do_checksum_package()
{
	atom_parse_path "$1"
	XGPATH_SCRIPT=$XGPATH_DB/$T/$N
	infofile=$XGPATH_SCRIPT/$N-$V$R.file

	xgfileinfo -c "$infofile" -root "$XGROOT"
	showOK "[***] check $N-$V$R done."

}

#check packge integrity. $1 is atom with type, such as "app-editors/vim-7.2.404"
#or only name with version, such as "vim-7.2.404"
#or only name, such as "vim"
gpkg_checksum()
{
	gpkg_find_insalled_pkg "$1"
	gpkg_do_checksum_package "$installed_xgb"
}
	

#install packge. $1 is atom with type, such as "app-editors/vim-7.2.404"
#or only name with version, such as "vim-7.2.404"
#or only name, such as "vim"
gpkg_do_build()
{
	local newest
	local ret
	local newv
	local newr

	#get xgb file
	gpkg_getxgbfile $1
	if [ $? == 0 ]; then
		#check if installed.
		atom_parse_path $newest
	
		#found, download it
		gpkg_begin_download $newest
		ret=$?
		if [ "$ret" == "0" ]; then
			#download ok, install it.
			gpkg_beginbuild $newest
		else
			return $ret
		fi

	else
		#not found
		return 1
	fi
}



gpkg_check_depmark()
{
	local pname="$T/$N-$V$R"
	local isHave

	isHave=${deplist["$pname"]}

	if [ -n "$isHave" ]; then
		#already have
		return 0
	else
		#add to list
		deplist["$pname"]=1
		return 1
	fi
}

#check packeg status. $1 is specified atom such as "vim-7.3.2" or "vim"
#return 0: no need upgrade. $newest is the newtest version xgb file 
#return 1: need upgrade. $newest is newest xgb file. $oldinst_atom is current atom
#return 2: need downgrade. $newest is newest xgb file. $oldinst_atom is current atom
#return 3: package is not installed, need installed to $newest
#return 4: package is not found
#return 5: package has already in list
#others: error

gpkg_check_packge()
{
	local inst_atom
	local iname
	local iver
	local irver
	local nname
	local nver
	local nrver

	#get xgb file
	gpkg_getxgbfile $1
	if [ "$?" == "0" ]; then
		#check if installed.
		atom_parse_path $newest
		gpkg_check_depmark
		if [ "$?" == "0" ]; then
			#already in list
			return 5
		fi
		gpkg_checkInst
		if [ "$?" == "0" ]; then 
			#not installed.
			return 3 
		else
			#installed. check version
			inst_atom=$oldinst_atom

			#echo "newest:    $newest"
			#echo "installed: $inst_atom"

			#reset old values
			atom_parse_path $newest
			nname="$N"
			nver="$V"
			nrver="$R"

			atom_parse $inst_atom
			iname="$N"
			iver="$V"
			irver="$R"

			#compare
			atom_cmp "$iname-$iver$irver" "$nname-$nver$nrver"
			case "$?" in
			"0")
				#echo "Same. No need upgrade"
				return 0
				;;
			"1")
				#echo "need downgrade"
				return 2
				;;
			"2")
				#echo "need upgrade"
				return 1
				;;
			*)
				return -1 
				;;
			esac

		fi
	else
		#package not found
		return 4
	fi

}

#install directly $1 is atom with type, such as "app-editors/vim-7.2.404"
#or only name with version, such as "vim-7.2.404"
#or only name, such as "vim"
gpkg_install_directly()
{
	local patom="$1"

	#check depdents
	su -p gpkg -c "export PATH=$PATH; $0 -buildraw $patom"
	err_check "make failed, exit."

	#no need root privilege to install package.
	gpkg_begin_install "$patom"

	return 0
}
	

#install packge. $1 is atom with type, such as "app-editors/vim-7.2.404"
#or only name with version, such as "vim-7.2.404"
#or only name, such as "vim"
gpkg_install_dep()
{
	local npath
	local iatom
	local ret
	local dep
	local leading
	local patom="$1"
	
	gpkg_check_packge "$1"
	case "$?" in
	"0")
		#no need update, return directly
		atom_parse_path $newest
		showOK "$T/$N-$V$R has already been installed"
		return 0;
		;;

	"1")
		#need upgrade
		;;

	"2")
		#need downgrade
		;;

	"3")
		#need install 
		;;
	"5")
		#already in list
		return 0
		;;

	*)
		#error
		exit 4
		;;
	esac

	atom_parse_path $newest
	showinfo "check dependances for $T/$N-$V$R..."

	#include file.
	. $XGPATH_LIB/template.xgb
	err_check "include xgb template file failed."

	#call init
	XGPATH_SCRIPT=$XGPATH_LIB/$T/$N
	XGPATH_SOURCE=$XGPATH_SOURCE_RAW/$N-$V$R
	. $XGPATH_SCRIPT/$N-$V$R.xgb
	err_check "include xgb file failed."

	xgb_init > /dev/null 2>&1
	err_check "call xgb_init failed"

	for dep in $DEPEND
	do
		gpkg_install_dep "$dep"
		err_check "Error: install $dep failed."
	done

	#remove old build 
	XGPATH_BUILD=/tmp/xiange/$N-$V$R
	rm -rf $XGPATH_BUILD

	showinfo "install $T/$N-$V$R..."
	gpkg_install_directly "$patom"
}

#install packge. $1 is atom with type, such as "app-editors/vim-7.2.404"
#or only name with version, such as "vim-7.2.404"
#or only name, such as "vim"
gpkg_install()
{
	local patom="$1"

	#/tmp to remove getcwd problems.
	cd /tmp

	#check if you're root
	if [ "$UID" != "0" ]; then
		showFailed "Installation need root privilege"
		exit 1
	fi

	#check if user gpkg avalible
	su -p gpkg -c "echo XGROOT is at $XGROOT/"

	if [ "$?" != "0" ]; then
		echo "create user gpkg for package compiling..."
		useradd -d /tmp -l -M gpkg
		err_check "create user gpkg failed."
	fi

	if [ "$pack_only" == "1" ]; then
		gpkg_install_directly "$patom"
	else
		gpkg_install_dep "$patom"
	fi
	return 0
}

gpkg_make_pack_only()
{
	pack_only="1"
	export pack_only=$pack_only
	gpkg_install "$1"
}

gpkg_begin_rmxgb()
{
	local newest
	local ret
	local iname
	local iver
	local irver
	local itype
	local dep
	local leading


	#get xgb file
	gpkg_getxgbfile $1
	if [ "$?" == "0" ]; then
		echo "delete $newest? (y/n)"
		read dep

		if [ "x$dep" == "xy" ]; then
			rm $newest
			gpkg_rm_dir_safe $XGPATH_LIB/$T/$N
		else
			echo cancel.
		fi
	fi
}

gpkg_cd_xgb()
{
	local newest
	local ret
	local iname
	local iver
	local irver
	local itype
	local dep
	local leading


	#get xgb file
	gpkg_getxgbfile $1
	if [ "$?" == "0" ]; then
		atom_parse_path $newest
		echo $XGPATH_DB/$T/$N
	fi
}

gpkg_cs_xgb()
{
	local newest
	local ret
	local iname
	local iver
	local irver
	local itype
	local dep
	local leading


	#get xgb file
	gpkg_getxgbfile $1
	if [ "$?" == "0" ]; then
		atom_parse_path $newest
		echo $XGPATH_LIB/$T/$N
	fi
}




#new xgb file, $1 is package name, $2 is version, $3 is type
gpkg_begin_new()
{
	local newest
	local ret
	local iname
	local itype
	local iver
	local irver
	local dep
	local leading

	case "${1}" in
	stage[0-4])
		vim $XGPATH_LIB/stages/$1
		exit 0
		;;
	esac

	if [ "$1" == "stage1" ]; then
		vim $XGPATH_LIB/stages/$1
		return 0
	fi
	if [ "$1" == "stage2" ]; then
		vim $XGPATH_LIB/stages/$1
		return 0
	fi

	#get xgb file
	gpkg_getxgbfile $1
	if [ "$?" == "0" ]; then
		vim $newest
	else
		echo "NO $1 found."
		atom_parse $1
		itype=$T
		iname=$N
		iver=$V
		irver=$R
		gpkg_getxgbfile $N
		if [ "$?" == "0" ]; then
			#found
			atom_parse_path "$newest"
			cp $newest $XGPATH_LIB/$T/$N/$N-$iver$irver.xgb
			vim $XGPATH_LIB/$T/$N/$N-$iver$irver.xgb
		else
			if [ "x$itype" == "x" ]; then
				echo "No type found, should be 'new sys-libs/glibc-2.32'"
				exit 3
			fi
			if [ "x$iver" == "x" ]; then
				echo "No version found, should be 'new sys-libs/glibc-2.32'"
				exit 4
			fi
			T=$itype
			N=$iname
			V=$iver
			R=$irver
			mkdir -p $XGPATH_LIB/$T/$N
			cp $XGPATH_LIB/template.xgb $XGPATH_LIB/$T/$N/$N-$iver$irver.xgb
			vim $XGPATH_LIB/$T/$N/$N-$iver$irver.xgb
		fi
		
	fi
}


# $1 is package name, such as "glibc", or "glibc-2.18"
# $2 is leading charaters before package name
gpkg_showdep()
{
	local newest
	local ret
	local iname
	local iver
	local irver
	local dep
	local leading
	local inst_atom


	#check if in global set.

	gpkg_check_packge "$1"
	case "$?" in
	"0")
		#no need update, return directly
		atom_parse_path $newest
		echo "${2} $N-$V$R (Installed)"
		#return 0;
		;;

	"1")
		#need upgrade
		atom_parse_path $newest
		showFailed "${2} $oldinst_atom ==> (U)$N-$V$R"
		cnt_install=$(($cnt_install+1))
		;;

	"2")
		#need downgrade
		atom_parse_path $newest
		showFailed "${2} $oldinst_atom ==> (D)$N-$V$R"
		cnt_install=$(($cnt_install+1))
		;;

	"3")
		#new install 
		atom_parse_path $newest
		showFailed "${2} $1 ==> (N)$N-$V$R"
		cnt_install=$(($cnt_install+1))
		;;

	"5")
		#already in list
		return 0
		;;

	*)
		#error
		return 4
	esac


	#not in global set, add it.

	#include file.
	. $XGPATH_LIB/template.xgb
	err_check "include xgb template file failed."

	#call init
	XGPATH_SCRIPT=$XGPATH_LIB/$T/$N
	XGPATH_SOURCE=$XGPATH_SOURCE_RAW/$N-$V$R
	. $XGPATH_SCRIPT/$N-$V$R.xgb
	err_check "include xgb file failed."

	xgb_init > /dev/null 2>&1
	err_check "call xgb_init failed"

	#check if package installed.
	#show all deps
	#echo ">>> DEP = $DEPEND"

	leading="${2}    "
	for dep in $DEPEND
	do
		gpkg_showdep "$dep" "$leading"	
		err_check "Error: DEP $dep Not found."
	done
}


#
# remove package
#

#operations when read a file.
# l = list files
# f = remove files/symbol links
# d = remove directorys
XG_CSV_OP="l"

gpkg_csvop_ls()
{
	case "${value[0]}" in
	D)
		#directory
		printf "%s| %8s| $INFO%s$NORMAL\n" "d" "${value[2]}" "${value[1]}"
		;;
	S)
		#Link
		printf "%s| %8s| $BRACKET%s$NORMAL\n" "l" "${value[2]}" "${value[1]}"
		;;
	F)
		#File
		printf "%s| %8s| $FAILURE%s$NORMAL\n" " " "${value[2]}" "${value[1]}"
		;;

	I)
		#totle
		printf "$WARNING\nFile: %s, Dir: %s, Link %d, Size: %dK$NORMAL\n" \
			"${value[1]}"\
			"${value[2]}" "${value[3]}" "${value[5]}"
		;;

	*)
		#unknown
		printf "%s| %8s| $FAILURE%s$NORMAL\n" " " "${value[2]}" "${value[1]}"
		;;

	esac
	
}

gpkg_csvop_rm_file()
{
	case "${value[0]}" in
	S)
		#symbol.
		unlink "$XGROOT${value[1]}"
		if [ "$?" == "0" ]; then
			echo "RM (S) ${value[1]}"
		else
			showFailed "RM (S) $XGROOT${value[1]} failed"
		fi
		;;
	F)
		#file
		unlink "$XGROOT${value[1]}"
		if [ "$?" == "0" ]; then
			echo "RM (F) ${value[1]}"
		else
			showFailed "RM (F) $XGROOT${value[1]} failed"
		fi
		;;
	O)
		#device or other
		unlink "$XGROOT${value[1]}"
		if [ "$?" == "0" ]; then
			echo "RM (O) ${value[1]}"
		else
			showFailed "RM (O) $XGROOT${value[1]} failed"
		fi
		;;
	D)
		#Directory.
		gpkg_mark_remove "${value[1]}"
		;;
	esac
	
}

gpkg_csvop_check_file()
{
	local cname

	cname="$XGROOT${value[1]}"

	case "${value[0]}" in
	S)
		#symbol.
		echo  "OK   (S) $XGROOT${value[1]}"
		;;
	F)
		#file
		if [ -f "$cname" ]; then
			gpkg_add_conflict "$cname"
			showFailed "FAIL (F) $cname exists"
		else
			echo  "OK   (F) $cname"
		fi
		;;
	D)
		#file
		if [ -f "$cname" ]; then
			gpkg_add_conflict "$cname"
			showFailed "FAIL (D) $cname is a file, please check."
		else
			echo  "OK   (D) $cname"
		fi

		;;
	I)
		#info
		showinfo  ">> check done."
		;;

	*)
		#file
		echo  "check        $XGROOT${value[1]}"

	esac
	
}

gpkg_csvop_mark_old()
{
	case "${value[0]}" in
	I)
		#info
		showinfo  ">> check old info done."
		;;
	*)
		delmark["${value[1]}"]="${value[0]}"
		;;
	esac
}

	
gpkg_csvop_update_file()
{
	local cname
	local oname
	local ftype
	local otype

	oname="${value[1]}"
	cname="$XGROOT${value[1]}"
	ftype=${value[0]}
	otype=${delmark["${value[1]}"]}

	case "${value[0]}" in
	S)
		#symbol.
		if [ -n "$otype" ]; then
			#found in old package, skip and remove mark
			unset delmark['${value[1]}']
			echo  "OK   (US) $cname"
		else
			#not found in old package
			showinfo  "OK   (NS) $XGROOT${value[1]}"
		fi
		;;
	F)

		#check in old file
		if [ -n "$otype" ]; then
			#found in old package, skip
			unset delmark['${value[1]}']
			echo  "OK   (UF) $cname"
		else
			#not found in old packge
			if [ -f "$cname" ]; then
				showFailed "FAIL (NF) $cname exists"
				gpkg_add_conflict "$cname"
			else
				showinfo  "OK   (NF) $cname"
			fi
		fi
		#file
		
		;;
	D)
		#dirctory
		if [ -n "$otype" ]; then
			#found in old package, skip
			unset delmark['${value[1]}']
			echo  "OK   (UD) $cname"
		else
			#new directory
			if [ -f "$cname" ]; then
				showFailed "FAIL (ND) $cname is a file"
				gpkg_add_conflict "$cname"
			else
				showinfo  "OK   (ND) $cname"
			fi
		fi
		;;
	I)
		#info
		showinfo  ">> check done."
		;;
	*)
		if [ -n "$otype" ]; then
			#found in old package, skip
			unset delmark['${value[1]}']
			echo  "OK   (U$ftype) $cname"
		else
			#new directory
			if [ -a "$cname" ]; then
				gpkg_add_conflict "$cname"
				showFailed "FAIL (ND) $cname exists"
			else
				showinfo  "OK   (N$ftype) $cname"
			fi
		fi
		;;
	
	esac
	
}


gpkg_mark_remove()
{
	gpkg_mark_remove_array[$mark_count]="$1"
	mark_count=$(($mark_count+1))
}

gpkg_reverse_remove()
{
	local totle=${#gpkg_mark_remove_array[*]}
	local i

	for ((i=$(($totle-1)); i>=0; i--))
	do
		gpkg_rm_dir_safe "$XGROOT${gpkg_mark_remove_array[$i]}"
	done
}

# read from stdin
gpkg_read()
{
	local line
	local count
	local -a value
	local rest="0"

	while IFS=, read -r -a value
	do
		count=${#value[*]}
		[ $count == 0 ] && continue

		case "$XG_CSV_OP" in
		l)
			gpkg_csvop_ls
			;;
		d)
			gpkg_csvop_rm_file
			;;
		c)
			gpkg_csvop_check_file
			;;
		u)
			gpkg_csvop_update_file
			;;
		o)
			gpkg_csvop_mark_old
			;;
		*)
			gpkg_csvop_ls
			;;
		esac
		unset value
	done
}

#read from file, and do it one by one
#$1 is total count.
gpkg_do_stage1()
{
	local line
	local count

	while IFS= read -r line
	do
		[ -z "$line" ] && continue
		((count++))
		showinfo "\n*** $count/$1 *** installing $line..\n"

		#check version
		gpkg_getxgbfile "$line"
		err_check "no .xgb file for $line."
		
		atom_parse_path "$newest"

		#check if binary package exist

		if [ -f "$XGPATH_PACKAGE/list/$T-$N-$V$R.mark" ]; then
			#exits
			showOK "$line has been already installed"
			continue
		fi

		#build package
		gpkg_make_pack_only "$T/$N-$V$R"

		#install binary package
		gpkg_upgrade_binary_package "$XGPATH_PACKAGE/$N-$V$R.xgp"


		mkdir -p $XGPATH_PACKAGE/list
		touch "$XGPATH_PACKAGE/list/$T-$N-$V$R.mark"


		[ "$?" != "0" ] && break
	done
}

gpkg_do_inst_stage()
{
	local line
	local count

	while IFS= read -r line
	do
		[ -z "$line" ] && continue
		((count++))
		showinfo "\n*** $count/$1 *** installing $line..\n"

		#check version
		gpkg_getxgbfile "$line"
		err_check "no .xgb file for $line."
		
		atom_parse_path "$newest"

		#check if binary package exist

		if [ -f "$XGPATH_PACKAGE/list/$T-$N-$V$R.mark" ]; then
			#exits
			showOK "$line has been already installed"
			continue
		fi

		#install binary package
		gpkg_upgrade_binary_package "$XGPATH_OLDPACKS/$N-$V$R.xgp"


		mkdir -p $XGPATH_PACKAGE/list
		touch "$XGPATH_PACKAGE/list/$T-$N-$V$R.mark"


		[ "$?" != "0" ] && break
	done
}

gpkg_ckstage_clear()
{
 	ckcount="0"
	ckbdcount="0"
	ckbadnames=""
}

gpkg_ckstage_showresult()
{
	local bdcnt=0

 	showinfo "$ckcount checked, $ckbdcount failed"
	for i in $ckbadnames ; 
	do
		bdcnt=$(($bdcnt+1))
		showFailed "$bdcnt\t\t$i"
	done
}

#read from file, and do it one by one
#$1 is total count.
gpkg_do_ck_stage1()
{
	local line
	echo "checking $1 packages form $XGPATH_OLDPACKS ..."

	while IFS= read -r line
	do
		[ -z "$line" ] && continue
		((ckcount++))
		#showinfo "\n*** $ckcount/$1 *** checking $line..\n"

		#check version
		gpkg_getxgbfile "$line"
		err_check "no .xgb file for $line."
		
		atom_parse_path "$newest"

		#check if binary package exist

		if [ -f "$XGPATH_OLDPACKS/$N-$V$R.xgp" ]; then
			#exits
			showOK "$ckcount $N-$V$R is OK"
			continue
		else
			#bad, record name
			showFailed "$ckcount $N-$V$R is failed"
			ckbadnames+=" $N-$V$R "
			((ckbdcount++))
		fi
	done

	}

#read from a file, $1 is file name, $2 is operation
gpkg_readfile()
{
	XG_CSV_OP=$2
	gpkg_read < $1
}

#
# list all installed packages
#

gpkg_list_inst_info()
{
	local -a value
	local t1
	local t2
	local tsize
	local ainfo

	atom_parse_path "$1"

	#get date.
	IFS=, read -r -a value < $XGPATH_DB/$T/$N/$N-$V$R.date
	t1=${value[0]}
	t2=${value[1]}

	#get size, 
	csv_split `tail -n 1 $XGPATH_DB/$T/$N/$N-$V$R.file`
	tsize=${value[5]}

	#get arch
	xg_getarch "$XGPATH_DB/$T/$N/$N-$V$R.para"
	if [ "$?" == "0" ]; then
		if [ "$xgp_native" ]; then
			ainfo="${xgp_arch}(N)"
		else
			ainfo="${xgp_arch}"
		fi
		printf "%s %s $INFO%6sK $SUCCESS%10s $FAILURE%s$NORMAL\n" $t1 $t2 $tsize $ainfo $N-$V$R
	else
		printf "%s %s $INFO%6sK $WARNING%10s $FAILURE%s$NORMAL\n" $t1 $t2 $tsize Unknown $N-$V$R
	fi

}

gpkg_list_installed()
{
	local gpkg_packs
	local pack
	local count=0


	gpkg_packs=`find -L $XGPATH_DB -iname *.xgb 2>/dev/null`
	
	for pack in $gpkg_packs
	do
		#echo $pack
		count=$(($count+1))
		gpkg_list_inst_info "$pack"
	done
}

gpkg_list_check_version()
{
	local oldv
	local oldn
	local oldr
	local oldt

	atom_parse_path "$1"
	oldt="$T"
	oldn="$N"
	oldv="$V"
	oldr="$R"

	gpkg_getxgbfile "$T/$N" 2>/dev/null
	if [ "$?" != "0" ]; then
		errpack[$errcount]="$oldt/$oldn-$oldv$oldr"
		errcount=$(($errcount+1))
		return 1
	fi
	atom_parse_path "$newest"

	atom_cmp "$oldn-$oldv$oldr" "$N-$V$R"
	case "$?" in
	"2")
		#need update
		ucount=$(($ucount+1))
		printf "$INFO%-6s %-20s $FAILURE(%s -> %s)$NORMAL\n" $ucount "$T/$N" "$oldv$oldr" "$V$R"
		;;
	*)
		;;
	esac
}

gpkg_list_check_upgrade()
{
	local gpkg_packs
	local pack
	local count=0
	local ucount=0
	local errcount=0
	local -a errpack


	gpkg_packs=`find -L $XGPATH_DB -iname *.xgb 2>/dev/null`

	showinfo ">> checking..."
	
	for pack in $gpkg_packs
	do
		#echo $pack
		count=$(($count+1))
		gpkg_list_check_version "$pack"
	done
	showinfo ">> done, $count packages checked, $ucount can be upgraded."
	if [ "$errcount" != "0" ]; then
		echo ""
		showFailed "below packages's build script cannot be found:"
		for ((i=0; i<$errcount; i++))
		do
			showFailed "$(($i+1))\t${errpack[$i]}"
		done
	fi
}

gpkg_list_check_new()
{
	local gpkg_packs
	local pack
	local count=0
	local ucount=0
	local pcount=0
	local phave
	local uniname

	declare -A packname 
	showinfo ">> checking..."
	gpkg_packs=`find -L $XGPATH_LIB -iname *.xgb 2>/dev/null`
	
	for pack in $gpkg_packs
	do
		#echo $pack
		count=$(($count+1))
		atom_parse_path "$pack"

		uniname="$T/$N"

		#check if already checked
		phave=${packname[$uniname]}
		if [ -n "$phave" ]; then
			#already have
			continue
		fi

		#record
		packname[$uniname]="1"
		pcount=$(($pcount+1))

		#check installed
		gpkg_checkInst
		if [ "$?" == "0" ]; then
			#not installed
			ucount=$(($ucount+1))
			echo -e "$ucount\t\t$T/$N"
		fi
	done

	showinfo "Done, $count build scripts found, $pcount packages checked, $ucount new"
	unset packname
}

#list, $1 is xgb path name
gpkg_list_showallfile()
{
	atom_parse_path "$1"
	gpkg_readfile "$XGPATH_DB/$T/$N/$N-$V$R.file" "l"
}

gpkg_list_package()
{
	gpkg_find_insalled_pkg "$1"
	err_check "list failed."
	gpkg_list_showallfile "$installed_xgb"
}

gpkg_remove_file_basedon_mark()
{
	local ftype

	# remove all files
	for i in "${!delmark[@]}"
	do
		ftype=${delmark["$i"]}

		case "$ftype" in

		S)
			#symbol.
			unlink "$XGROOT${i}"
			if [ "$?" == "0" ]; then
				echo "RM (S) ${i}"
			else
				showFailed "RM (S) $XGROOT${i} failed"
			fi
			unset delmark['$i']
			;;
		F)
			#file
			unlink "$XGROOT${i}"
			if [ "$?" == "0" ]; then
				echo "RM (F) ${i}"
			else
				showFailed "RM (F) $XGROOT${i} failed"
			fi
			unset delmark['$i']
			;;
		O)
			#device or other
			unlink "$XGROOT${i}"
			if [ "$?" == "0" ]; then
				echo "RM (O) ${i}"
			else
				showFailed "RM (O) $XGROOT${i} failed"
			fi
			unset delmark['$i']
			;;
		esac
	done

	local tmpraw
	local tmpsort

	tmpraw=/tmp/$UID/rm.$$.raw
	tmpsort=/tmp/$UID/rm.$$.sort

	exec 6>$tmpraw
	err_check "open $tmpraw failed."

	#remove all dirs in reversed order
	for i in "${!delmark[@]}"
	do
		ftype=${delmark["$i"]}

		case "$ftype" in
		D)
			echo "$i" >&6
			;;
		*)
			;;
		esac
	done

	exec 6>&-
	err_check "close $tmpraw failed."

	sort $tmpraw > $tmpsort
	
	local tdir

	while IFS= read -r tdir; 
	do
		gpkg_rm_dir_safe "$tdir"
	done < $tmpsort

	rm $tmpraw 2>/dev/null
	rm $tmpsort 2>/dev/null
}

#remove packet, $1=type_db_path, $2=$N, $3=$V if have, $4=$R if have
gpkg_do_remove_package_mark()
{
	local file
	local count
	local -a value
	local t1
	local t2
	local tsize
	local infofile
	local xgbfilen

	#echo "T=$1 N=$2 V=$3 R=$4"

	XGPATH_SCRIPT="$1/$2"
	#echo scriptpath $XGPATH_SCRIPT
	if [ -z "$3$4" ]; then
		#no version specified
		file=$(ls $XGPATH_SCRIPT/*.xgb 2>/dev/null | head -n 1 )
	else
		#version specified.
		file=$XGPATH_SCRIPT/$2-$3$4.xgb
	fi


	xgbfilen="$file"
	atom_parse_path $xgbfilen

	
	if [ -f "$xgbfilen" ]; then
		showinfo "remove $T/$N-$V$R..."
	else
		showFailed "$xgbfilen not found."
		exit 1
	fi

	infofile=$XGPATH_SCRIPT/$N-$V$R.file


	#call init
	. $XGPATH_SCRIPT/$N-$V$R.xgb
	err_check "include xgb file failed."

	XGPATH_SOURCE=$XGPATH_SOURCE_RAW/$N-$V$R
	xgb_init
	err_check "call xgb_init failed"

	#call pre rm
	xgb_prerm
	err_check "call xgb_prerm failed"


	gpkg_remove_file_basedon_mark

	xgb_postrm
	err_check "call xgb_postrm failed"

	#remove infos.
	gpkg_rm_packgeinfo

	#update last change time
	xgb_update_last

	showOK "[***] $N-$V$R removed."
}


#remove packet, $1=type_db_path, $2=$N, $3=$V if have, $4=$R if have
gpkg_do_remove_package()
{
	local file
	local count
	local -a value
	local t1
	local t2
	local tsize
	local infofile
	local xgbfilen

	#echo "T=$1 N=$2 V=$3 R=$4"

	XGPATH_SCRIPT="$1/$2"
	#echo scriptpath $XGPATH_SCRIPT
	if [ -z "$3$4" ]; then
		#no version specified
		file=$(ls $XGPATH_SCRIPT/*.xgb 2>/dev/null | head -n 1 )
	else
		#version specified.
		file=$XGPATH_SCRIPT/$2-$3$4.xgb
	fi


	xgbfilen="$file"
	atom_parse_path $xgbfilen

	
	if [ -f "$xgbfilen" ]; then
		showinfo "remove $T/$N-$V$R..."
	else
		showFailed "$xgbfilen not found."
		exit 1
	fi

	infofile=$XGPATH_SCRIPT/$N-$V$R.file


	#call init
	. $XGPATH_SCRIPT/$N-$V$R.xgb
	err_check "include xgb file failed."

	XGPATH_SOURCE=$XGPATH_SOURCE_RAW/$N-$V$R
	xgb_init
	err_check "call xgb_init failed"

	#call pre rm
	xgb_prerm
	err_check "call xgb_prerm failed"

	#reset directory list
		unset gpkg_mark_remove_array
	mark_count=0

	#remove all files
	gpkg_readfile $infofile "d"

	#remove all dirs
	gpkg_reverse_remove

	xgb_postrm
	err_check "call xgb_postrm failed"

	#remove infos.
	gpkg_rm_packgeinfo

	#update last change time
	xgb_update_last

	showOK "[***] $N-$V$R removed."

}

#find installed pkg. $1 can be "vim", or "vim-7.2", or "app-edit/vim-7.2"
#return 0 means found, xgb file is in installed_xgb
#others means not found.
gpkg_find_insalled_pkg()
{
	local findcount=0
	local pack

	atom_parse "$1"

	if [ "x$N" == "x" ]; then
		echo "No package specified."
		echo "Sample: "
		echo -e "\tgpkg -i vim"
		echo -e "\tgpkg -i vim-7.2.404"
		echo -e "\tgpkg -i app-editors/vim-7.2.404"
		exit 1
	fi



	if [ -z "$V" ]; then
		#no version specified
		fname="$N-*.xgb"
	else
		fname="$N-$V$R*.xgb"
	fi

	#echo "N=$rmN, V=$rmV, R=$rmR"

	if [ -n "$T" ]; then
		gpkg_packs=`find -L "$XGPATH_DB/$T/$N" -iname $fname 2>/dev/null`
	else
		gpkg_packs=`find -L $XGPATH_DB -iname $fname 2>/dev/null | grep "$N/"`
	fi

	for pack in $gpkg_packs
	do
		#echo $pack
		findcount=$(($findcount+1))
	done

	#echo $findcount
	[ "$findcount" == "0" ] && showFailed "package $1 is not installed." && return 1
	if [ "$findcount" -gt "1"  ]; then 
		showFailed "package $1 are too many. " 
		for pack in $gpkg_packs
		do
			echo $pack
		done
		return 2
	fi

	installed_xgb="$pack"
	return 0
}

gpkg_remove_package()
{
	gpkg_find_insalled_pkg "$1"
	atom_parse_path $installed_xgb
	gpkg_do_remove_package "$XGPATH_DB/$T" $N $V $R
}

#record confilict files, $1 is file name.
gpkg_add_conflict()
{
	cnt_conflic=$(($cnt_conflic+1))
	echo "$1" >> $file_conflict
}

#copy conflict file to /var/xiange/db/conflicts
#$1 is conflict file
gpkg_keep_conflict()
{
	local fconflict="$1"

	if [ -f $fconflict ]; then
		mkdir -p $XGPATH_DB/conflicts
		cp $fconflict $XGPATH_DB/conflicts
	fi
}

gpkg_wait_10sec()
{
	local i

	if [ "$cnt_conflic" == "0" ]; then
		return 0
	fi

	showFailed "$cnt_conflic conflict file found, Ctrl+C to abort, or 10 seconds to ignore"
	cat "$file_conflict" | nl
	for ((i=10; i>0; i--))
	{
		printf "%d " $i
		sleep 1
	}

	printf "\ncontinue.\n"

}

# input:
#	$1		: pathname of xgp file
# return: 
#	$dbpath	: 	dbpath
#	$packname: pathname of xgp file
#	$xibpath: tmp dir for info file
#	$xgbfile: pathname of xgp file

gpkg_extract_bininfo()
{
	#showinfo ">> parsing $1..."

	dbpath=${XGPATH_DB_RAW#/}
	packname=$1
	xibpath=/tmp/$UID/$$
	rm -rf $xibpath 2>/dev/null
	mkdir -p ${xibpath}
	err_check "[Error] make tmp $xibpath failed.\n"

	tar xf "$packname" -C $xibpath "$dbpath" 2>/dev/null
	err_check "Error: not xgp format"

	#fine xgbfile in package.
	xgbfile=$(find $xibpath/$dbpath -iname "*.xgb" 2>/dev/null)

	#check xgb
	[ -z "$xgbfile" ] && showFailed "Error: not xgp format" && exit 1
}

#
# input:
#	$xibpath
gpkg_clear_bininfo()
{
	rm -rf $xibpath 2>/dev/null
}

#
# input:
#	$packname
#	$xibpath
#	$T,N,V,R
gpkg_install_binary_package_raw()
{
	local infofile

	infofile="var/xiange/db/$T/$N/$N-$V$R.file"
	file_conflict="$xibpath/$N-$V$R.conflict"
	pushd $xibpath > /dev/null

	#check all files
	cnt_conflic="0"
	gpkg_readfile "$infofile" "c"
	popd
	rm -rf $infofile
	gpkg_wait_10sec

	showinfo ">> installing $T/$N-$V$R ..."

	#copy to root
	showinfo ">> Moving files to $XGROOT/ ..."
	tar xjpf "$packname" --keep-directory-symlink -C $XGROOT/ 
	err_check "[Error] copy binary package to / failed"

	gpkg_keep_conflict "$file_conflict"


	showinfo ">> Install OK, cleaning up.."

	#clear all routines by include template file
	if [ -f $XGPATH_LIB/template.xgb ]; then
		. $XGPATH_LIB/template.xgb
		err_check "[Error] $XGPATH_LIB/template.xgb not found."
	fi

	#prepare XGB_CONFIG
	export CFLAGS=$CFLAGS
	export CXXFLAGS=$CXXFLAGS
	export CPPFLAGS=$CFLAGS
	XGB_CONFIG="$XGINST_PREFIX "

	#include package build scripts
	XGPATH_SCRIPT=$XGPATH_DB/$T/$N
	XGPATH_SOURCE=$XGPATH_SOURCE_RAW/$N-$V$R
	. $XGPATH_SCRIPT/$N-$V$R.xgb
	err_check "[Error] $XGPATH_SCRIPT/$N-$V$R.xgb not found."

	#init build script file
	xgb_init

	#post install: only run in local installation
	if [ -z "$XGROOT" ]; then
		xgb_postinst
		err_check "[Error] call xgb_postinst failed"
	else
		showFailed "Note: xgb_postinst does not run when XGROOT set"
	fi

	#record last update time
	xgb_update_last

	showOK "[***] Binary package $N-$V$R installed to you system."
}

gpkg_install_binary_package()
{
	local xgbfile
	local atom
	local dbpath
	local packname
	local infofile

	showinfo ">> parsing $1..."
	gpkg_extract_bininfo "$1"

	atom_parse_path "$xgbfile"
	showinfo ">> checking $T/$N-$V$R ..."

	#check XG_DB_RAW
	if [ "$XGPATH_DB_RAW" != "/var/xiange/db" ]; then
		showFailed "XGPATH_DB_RAW changed to $XGPATH_DB_RAW."
		exit 2
	fi
	#get .file from packet
	mkdir -p ${xibpath}/bak/$T
	err_check "[Error] make tmp $xibpath failed.\n"

	gpkg_install_binary_package_raw

	gpkg_clear_bininfo
}

gpkg_upgrade_binary_package()
{
	local xgbfile
	local atom
	local dbpath
	local packname
	local infofile
	local newv
	local newr
	local newt
	local oldv
	local oldr
	oldfile=""

	declare -A delmark

	showinfo ">> parsing $1..."
	gpkg_extract_bininfo "$1"

	#echo "xgb=$xgbfile"
	atom_parse_path "$xgbfile"

	#echo "T=$T, N=$N, V=$V.."

	newv=$V
	newr=$R
	newt=$T

	showinfo ">> checking $T/$N.."
	gpkg_checkInst
	if [ "$?" == "0" ]; then
		#not installed
		gpkg_install_binary_package_raw
		return $?
	fi

	atom_parse $oldinst_atom

	#install forcely

	#if [ "$V$R" == "$newv$newr" ]; then
	#	showOK "$N-$V$R already installed, replace only"
	#fi


	showinfo ">> update $N-$V$R to $N-$newv$newr ..."
	oldv=$V
	oldr=$R
	V=$newv
	R=$newr
	T=$newt

	#check XG_DB_RAW
	if [ "$XGPATH_DB_RAW" != "/var/xiange/db" ]; then
		showFailed "XGPATH_DB_RAW changed to $XGPATH_DB_RAW."
		exit 2
	fi
	mkdir -p ${xibpath}/bak/$T
	#old .file
	if [ -f $XGPATH_DB/$T/$N/$N-$oldv$oldr.file ]; then
		mv $XGPATH_DB/$T/$N ${xibpath}/bak/$T
		err_check "copy $XGPATH_DB/$T/$N failed."
	else
		showFailed "$XGPATH_DB/$T/$N/$N-$oldv$oldr.file is not found."
		exit 1
	fi
	oldfile=$xibpath/bak/$T/$N/$N-$oldv$oldr.file
	if [ -f $oldfile ]; then
		echo "" > /dev/null
	else
		showFailed "$oldfile is not found."
		exit 2
	fi

	showinfo ">> parsing old package $N-${oldv}..."
	gpkg_readfile "$oldfile" "o"


	infofile="var/xiange/db/$T/$N/$N-$V$R.file"
	file_conflict="$xibpath/$N-$V$R.conflict"
	pushd $xibpath > /dev/null

	#check all files
	cnt_conflic="0"
	gpkg_readfile "$infofile" "u"

	popd 2>/dev/null
	rm -rf $infofile
	gpkg_wait_10sec

	#renamve oldname
	newname="$N_bak"

	showinfo ">> installing $T/$N-$V$R ..."

	#copy to root
	showinfo ">> Moving files to $XGROOT/ ..."
	tar xjpf "$1" --keep-directory-symlink -C $XGROOT/ 
	err_check "[Error] copy binary package to / failed"
	showinfo ">> Install OK, cleaning up.."

	gpkg_keep_conflict "$file_conflict"

	#remove old files
	gpkg_do_remove_package_mark "$xibpath/bak/$T" "$N" "$oldv" "$oldr"

	V=$newv
	R=$newr

	#clear all routines via template file
	if [ -f $XGPATH_LIB/template.xgb ]; then
		. $XGPATH_LIB/template.xgb
		err_check "[Error] $XGPATH_LIB/template.xgb not found."
	fi

	#prepare XGB_CONFIG
	export CFLAGS=$CFLAGS
	export CXXFLAGS=$CXXFLAGS
	export CPPFLAGS=$CFLAGS
	XGB_CONFIG="$XGINST_PREFIX "

	#include package build scripts
	XGPATH_SCRIPT=$XGPATH_DB/$T/$N
	XGPATH_SOURCE=$XGPATH_SOURCE_RAW/$N-$V$R
	. $XGPATH_SCRIPT/$N-$V$R.xgb
	err_check "[Error] $XGPATH_SCRIPT/$1 not found."

	#init build script file
	xgb_init

	#post install
	if [ -z "$XGROOT" ]; then
		xgb_postinst
		err_check "[Error] call xgb_postinst failed"
	else
		showFailed "Note: xgb_postinst does not run when XGROOT set"
	fi

	#record last update time
	xgb_update_last

	showOK "[***] Binary package $N-$V$R installed to you system."
	gpkg_clear_bininfo
}


gpkg_search_belonging()
{
	local packags
	local i
	local name
	local csv
	local outcnt=0
	local count=0
	local -a value


	packags=$(grep ",$1," `find -L $XGPATH_DB -iname "*.file" 2>/dev/null`)
	for i in $packags
	do
		((outcnt++))

		name=${i%%:*}
		name=${name%.file}
		atom_parse_path $name

		csv=${i#*:}
		csv_split $csv	

		echo -e "$FAILURE$T/$N-$V$R : $INFO${value[0]},${value[1]}"
	done

	if [ "$outcnt" == "0" ]; then
		echo ""
		echo -e $FAILURE"Not found. Please try with full path or regular expression, such as"
		echo -e "$INFO\tgpkg -S .*libgcc.*"
		echo -e "$INFO\tgpkg -S /usr/bin/gcc"
		echo ""
		return 1
	fi

	if [ "$outcnt" == "1" ]; then
		return 0
	fi

	return 2
}

gpkg_check_orphan()
{
	local line
	local tcount=0
	local orphan=0
	local conflict=0
	local outcnt=0
	local ret

	while IFS= read -r line
	do
		[ -z "$line" ] && continue
		((tcount++))
		gpkg_search_belonging $line > /dev/null
		ret=$?

		if [ "$ret" == "1" ]; then
			#orphan
			((orphan++))
			((outcnt++))
			printf "$NORMAL%6d %c $INFO%s\n" $outcnt "O" "$line"
		fi

		if [ "$ret" == "2" ]; then
			#orphan
			((conflict++))
			((outcnt++))
			printf "$NORMAL%6d %c $FAILURE%s\n" $outcnt "M" "$line"
		fi
	done

	showOK "Searched $tcount files, $orphan orphans, $conflict conflicts"

}

gpkg_find_orphans()
{
	echo "Searching orphans in $1.."
	find "$1" -type f 2>/dev/null | gpkg_check_orphan
}

#$1 is file
gpkg_check_rdep()
{
	local i
	local name
	local value

	packags=$(grep ",$1," `find -L $XGPATH_DB -iname "*.file" 2>/dev/null`)
	for i in $packags
	do

		name=${i%%:*}
		name=${name%.file}
		atom_parse_path $name
		value="$T/$N-$V$R"

		str_isIn "$sret" "$value"
		if [ "$?" == "0" ]; then
			#not found
			((rcount++))
			sret+="$value "
		fi
	done
}


gpkg_show_rdep()
{
	local bins
	local dlls
	local i
	local dp
	local sret=""
	local count=0
	local rcount=0
	local pcnt=0

	echo "Searching rdep for $1.."	

	bins=$(find /bin /usr/bin /sbin /usr/sbin  -type f 2>/dev/null)
	dlls=$(find /lib /usr/lib -type f -iname "*.so*" 2>/dev/null)
	printf "%-8dFound:%-4d" 0 0
	for i in $bins $dlls
	do
		((count++))
		((pcnt++))
		dp=$(ldd $i 2>/dev/null)
		str_isIn "$dp" "$1"
		if [ "$?" == "1" ]; then
			#fond.
			gpkg_check_rdep "$i"
		fi

		if [ $pcnt -gt 50 ]; then
			printf "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
			printf "%-8dFound:%-4d" $count $rcount
			pcnt=0
		fi

	done

	echo ""
	echo "Result:"
	count=0

	for i in $sret
	do
		((count++))
		printf "%-4d %s\n" $count $i
	done
}

#$1 is package name.
gpkg_rdep()
{
	local sofile
	local i

	sofile=$(gpkg -l $1 | grep "\.so$")
	if [ -z "$sofile" ]; then
		echo "Error: package $1 has no so file"
		exit 1
	fi

	for i in $sofile
	do
		str_isIn "$i" "so"
		if [ "$?" == "0" ]; then
			continue
		fi
		gpkg_show_rdep $(basename $i)
	done

}

xg_blfs_get_list()
{
	showinfo ">> getting the newest blfs book file.."
	wget -O ${nblfsfile}.tmp \
		http://www.linuxfromscratch.org/blfs/downloads/svn/
	err_check "get blfs file list failed."

	mv ${nblfsfile}.tmp $nblfsfile
	err_check "rename blfs tmp file failed."

	#get lfs book
	bookname2=$(grep -o "blfs-book-svn-html-[0-9-]*.tar.bz2" \
		$nblfsfile 2>/dev/null | head -n 1)

	if [ -z "$bookname2" ]; then
		showFailed "No blfs book found."
		exit 1
	fi

	showinfo ">> found blfs book: $bookname2"

	#get book
	wget -O ${bookname2}.tmp \
		http://www.linuxfromscratch.org/blfs/downloads/svn/$bookname2
	err_check "get blfs book $bookname2 failed."

	mv ${bookname2}.tmp $bookname2
	err_check "rename lfs book file failed."
}


# $1 is blfs book name, $2 is list file
xg_blfs_uncompress()
{
	local blfsdir
	blfsdir="blfsbook"
	mkdir -p $blfsdir
	tar xaf "$1" -C $blfsdir
	err_check "uncompress $1 failed."

	#remove leading space
	find blfsbook -type f -exec sed -i "s/^[\t ]*//g" '{}' ';'

	#remove \n
	find blfsbook -type f -exec sed -i ':a;N;$!ba;s/\n//g' '{}' ';'

	#gen list
	grep -R -o "Download:[^>]*" blfsbook/* >> $2
	grep -R -o "Download (HTTP):[^>]*" blfsbook/* >> $2
	grep -R -o "Download (FTP):[^>]*" blfsbook/* >> $2

}

xg_lfs_get_list()
{
	local bookname
	local bookname2

	mkdir -p $ntmpdir
	err_check "make dir $ntmpdir failed."
	
	cd $ntmpdir
	err_check "enter dir $ntmpdir failed."

	if [ -a ${nlfsfile}.tmp ]; then
		rm ${nlfsfile}.tmp
		err_check "remove tmp file failed."
	fi
	
	showinfo ">> getting the newest lfs book file.."
	wget -O ${nlfsfile}.tmp \
		http://www.linuxfromscratch.org/lfs/downloads/systemd/
	err_check "get lfs file list failed."

	mv ${nlfsfile}.tmp $nlfsfile
	err_check "rename tmp file failed."

	#get lfs book
	bookname=$(grep -o "LFS-BOOK-[0-9]*-systemd-NOCHUNKS.html.bz2" \
		$nlfsfile 2>/dev/null | head -n 1)

	if [ -z "$bookname" ]; then
		showFailed "Now lfs-systemd book found."
		exit 1
	fi

	showinfo ">> found book: $bookname"

	#get book
	wget -O ${bookname}.tmp \
		http://www.linuxfromscratch.org/lfs/downloads/systemd/$bookname
	err_check "get lfs book $bookname failed."

	mv ${bookname}.tmp $bookname
	err_check "rename lfs book file failed."

	xg_blfs_get_list  

	#uncompress
	bunzip2 $bookname
	bookname=$(basename $bookname .bz2)

	#dealwith it, first remove all leading space
	sed -i "s/^[\t ]*//g" $bookname
	err_check "rename leading space for $bookname failed."

	#remove /n
	sed -i ':a;N;$!ba;s/\n//g' $bookname
	err_check "rename newline mark for $bookname failed."

	#get list
	grep -o "Download:[^>]*" $bookname > $nlfsfile
	err_check "get download list failed."

	xg_blfs_uncompress "$bookname2" "$nlfsfile" 

	#remove leading
	sed -i "s/^.*href=\"//g" $nlfsfile
	err_check "remove leading mark of $nlfsfile failed."

	sed -i "s/\"$//g" $nlfsfile
	err_check "remove ending mark of $nlfsfile failed."

	touch $ntmpdir/timelist
	err_check "record list time failed."
	showinfo ">> OK"
}

xg_lfs_get_list2()
{
	mkdir -p $ntmpdir
	err_check "make dir $ntmpdir failed."
	
	cd $ntmpdir
	err_check "enter dir $ntmpdir failed."

	if [ -a ${nlfsfile}.tmp ]; then
		rm ${nlfsfile}.tmp
		err_check "remove tmp file failed."
	fi
	
	showinfo ">> getting the newest lfs-systemd file.."
	wget -O ${nlfsfile}.tmp \
		http://www.linuxfromscratch.org/lfs/downloads/development/$nlfsfile
	err_check "get lfs file list failed."

	mv ${nlfsfile}.tmp $nlfsfile
	err_check "rename tmp file failed."
	touch $ntmpdir/timelist
	err_check "record list time failed."
	showinfo ">> OK"
}

xg_lfs_compare_get()
{
	local t1
	local t2
	local t3
	if [ -a "$ntmpdir/timelist" ]; then
		touch $ntmpdir/timeck
		t1=$(date +"%s" -r $ntmpdir/timeck 2>/dev/null)
		t2=$(date +"%s" -r $ntmpdir/timelist 2>/dev/null)
		t3=$(($t1-$t2))

		if [ -z "$t1" ]; then
			showFailed "get tmp time failed."
			exit 2
		fi
		#showinfo ">> timecur=$t1"

		if [ -z "$t2" ]; then
			showFailed "get list time failed."
			exit 2
		fi
		#showinfo ">> timelist=$t2"
		#showinfo ">> timediff=$t3"

		if [ $t3 -gt 3600 ]; then
			showinfo ">> list file too old, update.."
			xg_lfs_get_list
		else
			showinfo ">> list got in 1 hour, use it."
		fi

		rm $ntmpdir/timeck
	else
		xg_lfs_get_list
	fi

}


#$1 is package name , $2 is version
xg_lfs_check_package()
{
	#check if fname OK
	#echo "name=|$1|, ver=|$2|"
	uniname="$1"
	haveit="${allname[$uniname]}"
	#echo "haveit=$haveit"
	if [ -n "$haveit" ]; then
		return 0
	fi

	#record it
	allname[$uniname]="1"
	
	gpkg_getxgbfile "$1" 2>/dev/null
	if [ "$?" == "0" ]; then
		#check if installed.
		atom_parse_path $newest

		#check version
		atom_vercmp "${V}" "$2" 2>/dev/null
		retv="$?"
		case "$retv" in
		"0")
			((samecount++))
			;;
		"2")
			#need update
			ucount=$(($ucount+1))
			printf "$INFO%-6s %-20s $FAILURE(%s -> %s)$NORMAL\n" \
				$ucount "$N" "$V" "$2"
			;;
		*)
			#showFailed "Unknown ret $retv ($N,$V ==>  $1,$2)"
			;;
		esac
		return 0
	else
		return 1
	fi

}


# $1 is raw name
xg_lfs_parsename2()
{
	local lname

	lname=${1,,}
	lfsn=$(echo $lname | grep -o "^[a-z]*")
	lfsv=$(echo $lname | grep -o "[0-9.]*" | head -n 1)

	#echo "lfsn=$lfsn, lfsv=$lfsv"

	if [ -z "$lfsn" ]; then
		return 1
	fi

	if [ -z "$lfsv" ]; then
		return 1
	fi

	#echo "lfsn=$lfsn, lfsv=$lfsv"

	xg_lfs_check_package "$lfsn" "$lfsv"
	if [ "$?" != "0" ]; then
		#not found
		return 1
	else
		return 0
	fi
}

#$1 is xgb file
xg_lfs_check_file()
{
	local lfsn
	local lfsv
	local retv
	T=""
	N=""
	V=""
	R=""
	#echo -e "\nchecking $fname..."
	atom_parse_path "$1"

	if [ -z "$N" -o -z "$V" ]; then
		#not found, try again
		xg_lfs_parsename2 "$fname"
		if [ "$?" != "0" ]; then
			#not found
			unknowna[cntunknown]="$fname"
			((cntunknown++))
			return 1
		fi
		return 0
	fi

	lfsn="${N,,}"
	lfsv="$V"

	xg_lfs_check_package "$lfsn" "$lfsv"
	if [ "$?" != "0" ]; then
		#not found, try again
		xg_lfs_parsename2 "$fname"
		if [ "$?" != "0" ]; then
			#not found
			unknowna[cntunknown]="$fname"
			((cntunknown++))
			return 1
		fi
	fi

	return 0
}

xg_lfs_parse_file()
{
	local line
	local fname
	local name2
	local xgbname
	declare -A allname
	declare -a unknowna
	local cntunknown=0
	local cnt=0
	local ucount=0
	local samecount=0
	local uniname
	local unifile
	local haveit
	declare -A allfile

	while IFS= read -r line
	do
		fname=$(basename $line 2>/dev/null) 

		if [ -z "$fname" ]; then
			continue
		fi

		#check if fname OK
		unifile="${fname,,}"
		haveit="${allfile[$unifile]}"
		#echo "haveit=$haveit"
		if [ -n "$haveit" ]; then
			continue
		fi
		allfile[$unifile]="1"
	
		#echo -e "\nchecking $fname..."
		name2=$(echo $fname | grep -o ".*-[0-9.]*")
		if [ -z "$name2" ]; then
			xg_lfs_check_file "$fname"
		else
			name2=${name2%.}
			xgbname="/lfs/${name2}.xgb"
			xg_lfs_check_file "$xgbname"
		fi
		((cnt++))
	done

	echo ""
	showinfo "$ucount can be updated, same: $samecount, unknown: $cntunknown"

	for ((i=0; i<$cntunknown; i++))
	do
		echo -e "$i\t${unknowna[i]}"
	done
	unset unknowna
	unset allname
	unset allfile
}

xg_lfs_check_update()
{
	#get list file
	xg_lfs_compare_get

	#parse list file
	xg_lfs_parse_file < $ntmpdir/$nlfsfile
}





#
# get max tmpfs size, in bytes
#
xg_gettmpsize()
{
	local memsize
	local swapsize
	memsize=$(free | awk '$1 == "Mem:" {print $2}')
	swapsize=$(free | awk '$1 == "Swap:" {print $2}')
	memsize=$(($memsize/2))
	tmpsize=$(($swapsize+$memsize))
}

# $1 is para file
xg_getarch()
{
	xgp_arch=$(fgrep "XGB_ARCH=" $1)
	if [ -z "$xgp_arch" ]; then
		xgp_arch="Unknown"
		xgp_native=0
		#showinfo "** ARCH=$xgp_arch"
		#showinfo "** NATIVE=$xgp_native"
		return 1
	else
		xgp_arch="${xgp_arch:10}"
		xgp_arch="${xgp_arch%\"}"

		xgp_native=$(fgrep "CFLAGS="  $1)
		xgp_native=$(echo $xgp_native | grep native)
		if [ "$?" == "0" ]; then
			#native
			xgp_native=1
		else
			xgp_native=0
		fi
		#showinfo "** ARCH=$xgp_arch"
		#showinfo "** NATIVE=$xgp_native"
		return 0;
		
	fi

}

#
# $1 is .xgp name
# return 
#	0 OK
#	1 failed
# 	parafile: pathname to .para file
#	T,N,V,R 
#	xgp_arch: Unknown, x86_64, i686, ARM, ..
#	xgp_native: 0,1
#
xg_ckeck_binary()
{
	gpkg_extract_bininfo "$1"


	atom_parse_path "$xgbfile"
	#showinfo ">> checking $T/$N-$V$R ..."

	parafile="${xgbfile%xgb}para"
	#showinfo "** para path=$parafile"

	xg_getarch "$parafile"
	return "$?"
}

#
# parse parameters
#


#reload parameters if available
[ -f $XGROOT/etc/xgparas ] && . $XGROOT/etc/xgparas

unset deplist
declare -A deplist

case "${1}" in
-v)
	#show version.
	echo $gpkg_version
	;;
-info)
	echo "XGB_ARCH=\"$XGB_ARCH\""
	echo "XGB_PREFIX=\"$XGB_PREFIX\""
	echo "CFLAGS=\"$CFLAGS\""
	echo 'CXXFLAGS="$CFLAGS"'
	echo "XG_I18N=\"$XG_I18N\""
	echo "XGB_CONFIG=\"$XGB_CONFIG\""
	echo "XGPARA_MAKE=\"$XGPARA_MAKE\""
	;;

-s)
	#search package.
	gpkg_search $2
	;;

-S)
	#search file belongs to which package.
	gpkg_search_belonging $2
	;;

-d)
	gpkg_download $2
	#download
	;;

-i)
	gpkg_install "$2"
	;;

-ip)
	gpkg_make_pack_only "$2"
	;;

-im)
	cd /tmp
	gpkg_do_build "$2"
	showinfo "exited."
	;;


-buildraw)
	#internal user only.
	#echo "pack=$pack_only"

	gpkg_do_build "$2"
	;;

-D)
	#remove package
	gpkg_remove_package $2
	;;

-c)
	gpkg_checksum $2
	;;

-I)
	#list installed packages, sort by installed time
	gpkg_list_installed $2
	;;

-cu)
	#check installed packgs can be upgrade
	gpkg_list_check_upgrade
	;;

-cn)
	#check new packages in xglibs
	gpkg_list_check_new
	;;

-l)
	#list files in packet.
	gpkg_list_package "$2"
	;;

-ib)
	gpkg_install_binary_package "$2"
	;;
-ub)
	gpkg_upgrade_binary_package "$2"
	;;


-F)
	gpkg_find_orphans $2
	;;

--sync)
	#sync with git.	
	mkdir -p $XGPATH_LIB
	err_check "[Error] Create dir $XGPATH_LIB failed."

	cd $XGPATH_LIB
	err_check "[Error] enter dir $XGPATH_LIB failed."

	if [ -d .git ]; then
		#alread exist.
		git pull
		err_check "[Error] pull from server failed."
	else
		cd ..
		#remove an system error.
		[ -d /etc ] || mkdir /etc
		[ -f /etc/hosts ] || touch /etc/hosts
		git config --system --add user.name xguser
		git config --system --add user.email xguser@xiangelinux.com
		git clone  $XG_GITSVR
	fi
	;;

selftest)
	#include test file
	. $(pwd)/gpkg-test
	err_check "[Error] self test not surpport"
	gpkg_test_bgin
	;;

stage[0-4])
	#compile stage
	#read from list, and install it one by one.
	lines=$(wc -l $XGPATH_LIB/stages/$1)
	gpkg_do_stage1 $lines  < $XGPATH_LIB/stages/$1
	;;

ckstage)
	#check stage
	if [ -z "$2" ]; then
		showFailed "Please specify stage number, such as gpkg ckstage 0 /var/xiange/packags\n\tor gpkg ckstage all /var/xiange/packages"
		exit 1
	fi
	if [ -z "$3" ]; then
		showFailed "Please specify compiled package directory , such as gpkg ckstage 0 /var/xiange/packags"
		exit 2
	fi

	if [ "$2" == "all" ]; then
		gpkg_ckstage_clear
		for i in 0 1 2 3
		do
			showinfo "ckstage $i..."
			#read from list, and install it one by one.
			lines=$(wc -l $XGPATH_LIB/stages/stage$i)
			XGPATH_OLDPACKS="$3"
			gpkg_do_ck_stage1 $lines  < $XGPATH_LIB/stages/stage$i
		done
		gpkg_ckstage_showresult
	else
		#read from list, and install it one by one.
		gpkg_ckstage_clear
		lines=$(wc -l $XGPATH_LIB/stages/stage$2)
		XGPATH_OLDPACKS="$3"
		gpkg_do_ck_stage1 $lines  < $XGPATH_LIB/stages/stage$2
		gpkg_ckstage_showresult
	fi

		;;

inststage)
	#install stage 
	if [ -z "$2" ]; then
		showFailed "Please specify stage number, such as gpkg inststage 0 /var/xiange/packags"
		exit 1
	fi
	if [ -z "$3" ]; then
		showFailed "Please specify compiled package directory , such as gpkg inst stage 0 /var/xiange/packags"
		exit 2
	fi

	#read from list, and install it one by one.
	lines=$(wc -l $XGPATH_LIB/stages/stage$2)
	XGPATH_OLDPACKS="$3"
	gpkg_do_inst_stage $lines  < $XGPATH_LIB/stages/stage$2
	exit 0
	;;



-chroot)
	#chroot to new system.
	#$1=-chroot
	#check parameter
	shift
	if [ -z "$1" ]; then
		echo "Please specify destination, such as:"
		echo -e "\t gpkg chroot /mnt/xg /bin/bash"
		exit 1
	fi
	newroot=$1

	shift
	if [ -z $1 ]; then
		bashfile="/bin/bash"
	else
		bashfile="$@"
	fi


	#first, check tmpfs

	mkdir -p $newroot/tmp
	chmod 1777 $newroot/tmp
	umount $newroot/tmp 2>/dev/null

	xg_gettmpsize
	if [ "$tmpsize" -ge "3000000" ]; then
		showOK ">> tmpfs size check OK, enabled."
		#mount tmp fs.
       	mount -t tmpfs tmpfs $newroot/tmp -o size=$tmpsize
		err_check "Error: mount $newroot/tmp failed."
	else
		echo -e $WARNING">> tmpfs is too small, disabled"$NORMAL
	fi
	#mount proc/sysfs/devfs
	mkdir -p $newroot/proc
    mkdir -p $newroot/sys
    mkdir -p $newroot/dev

	umount $newroot/proc 2>/dev/null
    umount $newroot/sys 2>/dev/null
    umount $newroot/dev 2>/dev/null

	mount -t proc none $newroot/proc
	err_check "Error: mount $newroot/proc failed."
    mount -t sysfs none $newroot/sys
	err_check "Error: mount $newroot/sys failed."
    mount --bind /dev $newroot/dev
	err_check "Error: mount $newroot/dev failed."

	#prepare resolv.conf
	[ -d $newroot/etc ] || mkdir $newroot/etc
    [ -f $newroot/etc/resolv.conf ] || cp /etc/resolv.conf $newroot/etc


	#chroot
	envfile="/usr/bin/env"

	chroot $newroot $envfile -i \
		HOME=/root TERM="$TERM" PS1='\u:\w\$ ' \
		PATH=/bin:/usr/bin:/sbin:/usr/sbin \
		XGSIGN=xg_chroot\
		$bashfile
	err_check "Error: chroot to $newroot failed."
	;;

-unchroot)
	#check parameter
	if [ -z "$2" ]; then
		echo "Please specify destination, such as:"
		echo -e "\t gpkg unchroot /mnt/xg"
		exit 1
	fi

	showinfo ">> unmounting $2.."
	umount  $2/tmp 2>/dev/null
	
	umount  $2/proc
	err_check "Error: unmount $2/proc failed."
	umount  $2/sys
	err_check "Error: unmount $2/sys failed."
	umount  $2/dev
	err_check "Error: unmount $2/dev failed."
	showOK "unmount $2 OK"
	;;
-p)
	#show dependece

	#unset DEP,RDEP
	cnt_install="0"

	#show dependant
	gpkg_showdep $2 ""

	showinfo "Packages need to be installed: $cnt_install"
	;;

-rdep)
	#show reverse dep for specified library
	gpkg_rdep "$2"
	;;

-pack)
	#check paras
	if [ -z "$2" ]; then
			echo "Please specify directory contains package files."
			exit 1
	fi

	if [ -z "$3" ]; then
			echo "Please specify package name."
			exit 1
	fi

	if [ -z "$4" ]; then
			echo "Please specify package version"
			exit 1
	fi

	
	T="pack"
	N=$3
	V=$4
	R=$5
	XGPATH_BUILD=/tmp/xiange/$N-$V$R
	XGPATH_DEST=$XGPATH_BUILD/pack


	#copy all files to pack directory.
	rm -rf $XGPATH_DEST
	mkdir -p $XGPATH_DEST
	cp -a $2/* $XGPATH_DEST

	echo packing $N-$V$R...

	gpkg_dopack

	#copy all files to dest 
	;;

-packraw)
	gpkg_begin_install "$2"
	;;

-cklfs)
	xg_lfs_check_update 
	;;



edit)
	gpkg_begin_new "$2"
	;;

new)
	gpkg_begin_new "$2"
	;;

rm)
	gpkg_begin_rmxgb "$2"
	;;

cd)
	gpkg_cd_xgb "$2"
	;;

cs)
	gpkg_cs_xgb "$2"
	;;

-ckb)
	#check package
	xg_ckeck_binary "$2"
	if [ "$xgp_native" == "1" ]; then
		showinfo "$T/$N-$V$R: $xgp_arch (Native)"
	else
		showinfo "$T/$N-$V$R: $xgp_arch"
	fi
	echo "Paras:"
	cat $parafile

	;;



*)
	#show usage 
	gpkg_show_usage
	exit 0
	;;
esac


